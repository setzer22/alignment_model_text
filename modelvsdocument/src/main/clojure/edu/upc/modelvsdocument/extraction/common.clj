(ns edu.upc.modelvsdocument.extraction.common
  (:gen-class)
  (:require [edu.upc.modelvsdocument.extraction.macros]
            [edu.upc.modelvsdocument.bpmn :as bpmn]
            [edu.upc.modelvsdocument.wordnet :as wn]
            [edu.upc.modelvsdocument.sorter.model-sorter :as modelsorter]
            [edu.upc.modelvsdocument.config :refer [config]]
            [clojure.spec :as spec]
            [clojure.spec.test :as stest]
            [clj-http.client :as client]
            [edu.upc.modelvsdocument.textserver :as textserver]
            [clojure.data.json :as json]
            [clj-xpath.core :as xpath]
            [edu.upc.modelvsdocument.schemas :as t :refer :all]
            [edu.upc.modelvsdocument.extraction.feature])
  (:use [com.rpl.specter]
        [clojure.pprint]
        [edu.upc.modelvsdocument.extraction.feature]
        [edu.upc.modelvsdocument.utils])
  (:import [edu.upc.modelvsdocument.extraction.feature Feature]))


(def pos-filter
  "POS tags in this list are considered stopwords and are removed from the sentence"
  ["punctuation", "preposition", "determiner", "modal", "conjunction", "particle"])

(spec-fn non-stopword? ::t/token)
(defn non-stopword? [token]
  "Is the token considered a stopword?"
  (not (in? pos-filter (:pos token))))

;; Precompiled paths
(def ALL-SENTENCES
  "Selects all the sentences in the analyzed text"
  (comp-paths [:paragraphs ALL :sentences ALL]))

(def TOKENS
  "Selects all non-stopword tokens in a sentence"
  (comp-paths [:tokens ALL non-stopword?]))

(spec-fn verb? ::t/token)
(defn verb? [token] (= "verb" (:pos token)))

(spec-fn find-token-in-text ::t/text ::t/id)
(defn find-token-in-text [text id]
  (select-one [ALL-SENTENCES :tokens ALL #(= (:id %) id)] text))

(spec-fn token-of-id ::t/sentence ::t/id)
(defn token-of-id [s tk-id]
  (select-one [:tokens ALL #(= tk-id (:id %))] s))

(spec-fn token-list-of-role ::t/sentence (spec/keys :req-un [::from ::to]) -> ::t/tokens)
(defn token-list-of-role [s {:keys [from to]}]
  (let [[_, _  , fst] (re-find #"t(\d+)\.(\d+)" from)
        [_, sid, lst] (re-find #"t(\d+)\.(\d+)" to)
        tk-range (map #(str "t" sid "." %)
                      (range (Integer/parseInt fst) (inc (Integer/parseInt lst))))]
    (map (partial token-of-id s) tk-range)))

(spec-fn token-lemma ::t/sentence ::t/id)
(defn token-lemma [s tk-id]
  (first (select [:tokens ALL #(= tk-id (:id %)) :lemma] s)))

(defn relevant-predicates-in
  "Returns the relevant predicates in s. A relevant predicate is a
   predicate that was generated from a personal verb. Predicates
   generated by nouns, gerunds or participles are excluded."
  [s]
  (let [predicates (select [:predicates ALL] s)]
    (filter
     (fn [predicate]
       (let [head-token-id (:head_token predicate)
             head-token (token-of-id s head-token-id)]
         (and
          (= (:pos head-token) "verb")
          (#{"personal" "participle" "infinitive"} (:vform head-token)))))
     predicates)))


(defn heads-of-role-type
  "Returns the head tokens in s that constitute a predicate role of role.
   E.g. arg-type=A1 returns all the agent head tokens in s"
  [s role]
  (mapcat
   (fn heads-in-pred [predicate]
     (let [head-token-ids (select [:arguments ALL #(= role (:role %)) :head_token] predicate)
           head-tokens (filter non-stopword? (map (partial token-of-id s) head-token-ids))]
       head-tokens))
   (relevant-predicates-in s)))

(defn tokens-of-role-type
  "Returns all relevant tokens in s that constitute a predicate role of role.
   E.g. arg-type=A1 returns all the agent tokens in s"
  [s role]
  (mapcat
   (fn heads-in-pred [predicate]
     (let [arguments (select [:arguments ALL #(= role (:role %))] predicate)
           tokens-of-argument (filter non-stopword? (mapcat #(filter non-stopword? (token-list-of-role s %)) arguments))]
       tokens-of-argument))
   (relevant-predicates-in s)))

(comment

  (relevant-predicates-in
   (second (select [ALL-SENTENCES] edu.upc.modelvsdocument.extraction.model-extraction/--text)))

  (select
   [:predicates ALL]
   (second (select [ALL-SENTENCES] edu.upc.modelvsdocument.extraction.model-extraction/--text)))

  (select [:arguments ALL #(= "A1" (:role %)) ]
          (first (relevant-predicates-in (first (select [ALL-SENTENCES] edu.upc.modelvsdocument.extraction.model-extraction/--text)))))

  (select
   [:predicates ALL]
   (first (select [ALL-SENTENCES] edu.upc.modelvsdocument.extraction.model-extraction/--text)))

  (tokens-of-role-type (second (select [ALL-SENTENCES] edu.upc.modelvsdocument.extraction.model-extraction/--text))
                       "A1")
  )

(defn token-sense-features [feature-type, {sense :wn :as token}, tf-idf]
  (when sense
    (let [multiplier (config :hiperonimy-multiplier)]
      (concat
       [(has-synset [feature-type sense] tf-idf)]
       (map #(has-parent-synset [feature-type %1] (* tf-idf %2))
            (take (config :hiperonimy-chain-length) (wn/hiperonimy-chain-of sense))
            (iterate #(* % multiplier) 1.0))))))


(spec-fn senses-of-token ::t/token)
(defn senses-of-token [token]
  (comment (if (:senses token)
     (->> (:senses token)
          (sort-by :pgrank)
          (take (config :synset-candidate-width))
          (map :wn))
     [(:wn token)]))
  [(:wn token)])

(spec-fn make-synset-and-hypernym-features (spec/* (spec/tuple ::t/wordnet-id number?)))
(defn make-synset-and-hypernym-features [synsets-and-weights]
  (let [synset-features (map #(has-synset [(first %)] (second %)) synsets-and-weights)
                                        ;TODO: Add tf-idf weights to the parents too!

        hypernyms-and-weights (map (fn [[synset weight]]
                                     [(take (config :hiperonimy-chain-length)
                                            (wn/hiperonimy-chain-of synset))
                                      weight])
                                   synsets-and-weights)

        multiplier (config :hiperonimy-multiplier)
        weights    (iterate #(* % multiplier) 1.0)

        hypernym-features (mapcat
                           (fn [[hypernyms tfidf-weight]]
                             (map #(has-parent-synset [%1] (* tfidf-weight %2)) hypernyms weights))
                           hypernyms-and-weights)]
    (concat synset-features hypernym-features)))
